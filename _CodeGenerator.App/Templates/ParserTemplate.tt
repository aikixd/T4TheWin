<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="_CodeGenerator.Definitions.Syntax" #>

// Generated by: ParserTemplate.tt

using System.Collections.Generic;

namespace <#= this.ClassInfo.Namespace #>
{
	partial class <#= this.ClassInfo.Name #>
	{
<#
	foreach (var syntax in this.SyntaxParts)
    {
        {
			if (syntax is SyntaxList s &&
				s.Flags == SyntaxListFlags.SkipParserGeneration)
				continue;
        }
		
		switch (syntax)
        {
			case Stream _:
				#>

		public bool CanParse<#= syntax.GetType().Name #>(Lexer lexer, string[] stopSignals)
		{
			return this.TryParse<#= syntax.GetType().Name #>(lexer, stopSignals, out var _);
		}
		
		// <#= syntax.GetType().BaseType.Name #>
		public bool TryParse<#= syntax.GetType().Name #>(Lexer lexer, string[] stopSignals, out <#= syntax.GetType().Name #> result)
		{

				<#
				break;

			default:
#>

		public bool CanParse<#= syntax.GetType().Name #>(Lexer lexer)
		{
			return this.TryParse<#= syntax.GetType().Name #>(lexer, out var _);
		}
		
		// <#= syntax.GetType().BaseType.Name #>
		public bool TryParse<#= syntax.GetType().Name #>(Lexer lexer, out <#= syntax.GetType().Name #> result)
		{
<#
				break;
		} // switch(syntax), alternate method signatures

		switch (syntax)
        { 
			/***** Delimited text syntax *****/
			case DelimitedTextSyntax dts:
				#>

			var syntaxList = new List<I<#= dts.Name #>SyntaxContent>(1024);

			while (
				lexer.CanRead() 
				&& <#=
				string.Join(
					"				&& ",
					dts.FollowedBy
					.Select(x => $"this.CanParse{x.GetType().Name}(lexer) == false")
				)
				#>)

			{ <#
				foreach (var d in dts.Delimitations)
                { #>

				{
					if (this.TryParse<#= d.GetType().Name #>(lexer, out var r))
					{
						syntaxList.Add(r);
						continue;
					}
				}

<#
				} // foreach d in delimitations
				#>

				{
					if (this.TryParse<#= dts.Stream.GetType().Name #>(
						lexer, 
						<#= this.MakeStringList(dts.Stream.Disallowed.Select(x => x.Text)) #>,
						out var r))
					{
						syntaxList.Add(r);
						continue;
					}
				}

			}

			result = new <#= dts.GetType().Name #>(syntaxList);
			return true;
				<#
			 	break; // case DelimitedTextSyntax dts

			/***** Syntax list *****/
			case SyntaxList sl:
				#>

			var list = new List<I<#= sl.Name #>Content>(1024);

			while (lexer.CanRead())
			{
<#
				foreach (var s in sl.Syntax)
                { #>
				{
					if (this.TryParse<#= s.GetType().Name #>(lexer, out var r))
					{
						list.Add(r);
						continue;
					}
				}
				
<#
                }
				#>
			}

			result = new <#= sl.GetType().Name #>(list);
			return true;

				<#
				break; // Case SyntaxList sl

			case Stream stream:
				#>

			var list = List<>
				
			while (lexer.CanRead())
			{
				var 
			}

				<#
				break; // Stream stream

			/***** Syntax *****/
			case Syntax s:
				for (int ic = 0; ic < s.Combinations.Length; ic += 1)
                {
					Write("			if (" + Environment.NewLine);

					// When no parts are present in a combination 'if' statement must have a condition
					if (s.Combinations[ic].Parts.Length == 0)
						Write("                true");

					for (int ip = 0; ip < s.Combinations[ic].Parts.Length; ip += 1)
					{
						var part = s.Combinations[ic].Parts[ip];
						var name = part.GetType().Name;
						
#>
				this.TryParse<#= name #>(lexer, out var syntaxPart<#= ip #>)<# if (ip + 1 != s.Combinations[ic].Parts.Length) { Write(" &&" + Environment.NewLine); } 

                    } // for ip in combination.parts

					Write(")" + Environment.NewLine);
					#>
			{
				result = new <#= syntax.GetType().Name #>(<#=
					string.Join(
						", ",
						s.Combinations[ic].Parts
						.Select((x, i) => $"syntaxPart{i}")) #>);
				return true;
			}

<#
                } // for ic in s.combinations
				#>
			result = null;
			return false;
				<#
				break; // case Syntax s


        } // switch syntax
#>
		
		} // Parse method end
<#
    } // foreach syntax in syntax parts 
#>
	}
}